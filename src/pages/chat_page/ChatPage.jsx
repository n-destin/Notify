/* eslint-disable array-callback-return */
/* eslint-disable no-plusplus */
/* eslint-disable no-empty */
/* eslint-disable no-use-before-define */
/* eslint-disable no-shadow */
/* eslint-disable no-unused-vars */
/* eslint-disable react/prop-types */
/* eslint-disable react/jsx-indent-props */
/* eslint-disable react/no-array-index-key */
/* eslint-disable import/no-extraneous-dependencies */
import './ChatPage.css';
import React, { useState, useEffect, useRef } from 'react';
// This enables streaming from OpenAI API (https://www.npmjs.com/package/sse)
import { SSE } from 'sse.js';
import { useParams } from 'react-router-dom';
import * as Firebase from '../../services/firebase';
import { auth } from '../../services/dataStore';

function ChatPage() {
    // Store message history (to render from firebase)
    const [messages, setMessages] = useState([]);
    const [inputValue, setInputValue] = useState('');
    const [inputDisabled, setInputDisabled] = useState(false);

    const currentURL = window.location.href;
    const lastSlashIndex = currentURL.lastIndexOf('/');
    const lectureId = currentURL.substring(lastSlashIndex + 1);

    // Transcript information we will retrieve from Firebase
    const [transcriptName, setTranscriptName] = useState('');
    const [transcriptContent, setTranscriptContent] = useState('');

    function handleInputChange(event) {
        setInputValue(event.target.value);
    }

    const user = auth.currentUser;
    // ge the lecture
    useEffect(() => {
        Firebase.getLecture(user.uid, lectureId, (data) => {
            setTranscriptName(data.file_name);
            setTranscriptContent(data.transcript);
        });
    }, []);

    // function setContent (){
    //   (Transcript.Title? setTranscriptName(Transcript.Title) : '');

    // };
    // Annoying ass shit
    function updateHasBeenCalled(index) {
        const newMessages = [...messages];
        messages[index].hasBeenCalled = true;
        setMessages(newMessages);
    }

    async function handleSubmit(event) {
        // Disable input to prevent rage click
        event.preventDefault();
        setInputDisabled(true);

        // Add user message
        const newMessage = {
            type: 'user',
            content: inputValue,
            hasBeenCalled: false,
        };

        // Adds user message to list of messages
        setMessages((prevMessages) => [...prevMessages, newMessage]);
        Firebase.newChat(user.uid, lectureId, newMessage);
        // Add server message
        const serverResponseMessage = { type: 'server', content: inputValue };
        setMessages((prevMessages) => [...prevMessages, serverResponseMessage]);

        // Enables/disables input when the message is being generated by OpenAI
        setInputValue('');
        setInputDisabled(false);
    }

    return (
        <div className="min-h-screen flex flex-row max-h-screen gradient">
            {/* Transcript */}
            <div className="overflow-y-auto p-4 bg-white rounded-lg shadow-lg backdrop-filter backdrop-blur-lg bg-opacity-30 mt-5 ml-5 mr-5 blur-gradient max-w-[50vw]">
                <h1 className="font-bold text-2xl mb-4 pl-4">{transcriptName}</h1>
                <p className="whitespace-break-spaces pl-4 pr-4">{transcriptContent}</p>
            </div>
            <div className="mt-5 flex flex-col flex-grow max-w-[50vw] bg-gray-200 rounded-lg shadow-lg backdrop-filter backdrop-blur-lg bg-opacity-30 ml-5 mr-5">
                {/* Chat history */}
                <div className="flex-grow p-4 overflow-y-auto">
                    {/* to render from firebase */}
                    {messages.map((message, index) => (
                        <div key={index} className="mb-2">
                            {message.type === 'user' ? (
                                <UserChatMessage key={index} content={message.content} hasBeenCalled={message.hasBeenCalled} updateHasBeenCalled={() => updateHasBeenCalled(index)} />
                            ) : (
                                <ServerChatMessage key={index} initialContent={message.content} hasBeenCalled={message.hasBeenCalled} updateHasBeenCalled={() => updateHasBeenCalled(index)} />
                            )}
                        </div>
                    ))}
                </div>

                {/* Chat input */}
                <form className="p-4 flex " onSubmit={handleSubmit}>
                    <input
                        type="text"
                        className="flex-grow border text-black border-gray-300 px-4 py-2 focus:outline-none w-full bg-[#d7d7d7] bg-opacity-50 backdrop-filter backdrop-blur-md rounded-xl"
                        placeholder="Type a message..."
                        value={inputValue}
                        onChange={handleInputChange}
                        disabled={inputDisabled}
                    />
                    <button
                        type="submit"
                        className="bg-[#7F1BBD] hover:bg-[#7300bb] text-white rounded-xl px-4 py-2 ml-2 w-auto"
                        disabled={inputDisabled}
                    >
                        Send
                    </button>
                </form>
            </div>
        </div>
    );
}

export default ChatPage;

// User chat message component
function UserChatMessage({ content }) {
    console.log('The client is rendering.');
    return (
        <div className="pt-4 pb-4 pr-5 bg-blue-200 text-black text-right rounded-xl pl-5">
            {content}
        </div>
    );
}

// Server chat message component
function ServerChatMessage({
    initialContent, hasBeenCalled, updateHasBeenCalled, serverMessage = {
        type: 'server',
        content: '',
        hasBeenCalled: false,
    },
}) {
    const currentURL = window.location.href;
    const lastSlashIndex = currentURL.lastIndexOf('/');
    const lectureId = currentURL.substring(lastSlashIndex + 1);

    const [responseId, setResponseId] = useState('');

    const [serverSideMessage, setServerSideMessage] = useState('');
    const serverSideMessageRef = useRef();
    const user = auth.currentUser;

    // Updates state whenever new tokens are streamed. Need to update Firebase here
    useEffect(() => {
        serverSideMessageRef.current = serverSideMessage;
    // Firebase.changeContent(user.uid, lectureId, responseId, serverSideMessage)
    }, [serverSideMessage]);

    // Only calls API once - does not call on re-renders (CRITICAL)
    if (!hasBeenCalled) {
        const responseId = Firebase.newChat(user.uid, lectureId, serverMessage);
        console.log(responseId);
        setResponseId(responseId);
        streamContent(responseId);
        updateHasBeenCalled();
    }

    async function streamContent(serverChatId) {
        const API_KEY = ''; // need to make ENV var
        const url = 'https://api.openai.com/v1/chat/completions';

        const data = {
            model: 'gpt-3.5-turbo',
            temperature: 0.5,
            max_tokens: 500,
            stream: true,
            messages: [{ role: 'user', content: initialContent }],
        };

        // Call API, open stream
        const source = new SSE(url, {
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${API_KEY}`,
            },
            method: 'POST',
            payload: JSON.stringify(data),
        });

        const messageQueue = [];
        let processingMessage = false;
        let serverResponse = '';

        // SSE - listens for mesages, adds to queue
        source.addEventListener('message', (e) => {
            if (e.data !== '[DONE]') {
                const payload = JSON.parse(e.data);
                const text = payload.choices[0].delta.content;
                messageQueue.push(text);
                if (!processingMessage) {
                    processNextMessage();
                }
                serverResponse += text;
            } else {
                source.close();
            }
        });

        // SSE - processes message by appending each char from the message to state
        function processNextMessage() {
            const text = messageQueue.shift();
            if (text) {
                let i = 0;
                processingMessage = true;
                const intervalId = setInterval(() => {
                    if (i < text.length) {
                        const char = text.charAt(i);
                        if (char !== '\n') {
                            // We are updating state char by char, so we could update Firebase similarly

                            serverSideMessageRef.current += char;
                            setServerSideMessage(serverSideMessageRef.current);
                        }
                        i++;
                    } else {
                        clearInterval(intervalId);
                        processingMessage = false;
                        processNextMessage();
                    }
                }, 15);
            }
        }
        // SSE - adds event listener and begins streaming
        source.addEventListener('readystatechange', (e) => {
            if (e.readyState >= 2) {
            }
        });
        source.stream();
    }

    return (
        <div className="mb-2 bg-red-50 text-black text-left pt-4 pb-4 pl-5 rounded-xl bg-opacity-30 pr-5">
            {serverSideMessage}
        </div>
    );
}
